{"title":"关于Android线程","slug":"about-android-thread","date":"2019-02-13T22:05:32.000Z","updated":"2020-08-31T21:43:07.715Z","comments":true,"path":"api/articles/about-android-thread.json","excerpt":null,"covers":["/assets/blogimg/andy-lg.png","/assets/blogimg/2019-02-14.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/assets/blogimg/andy-lg.png\" alt=\"banner\"></p>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>众所周知,android只能在主线程中更新UI视图,而一些诸如网络请求,socket通讯和Json解析之类比较耗时的操作一般放在子线程(用线程池来管理便于回收)中处理,否则会阻塞(zu se)UI线程.那么子线程中处理的结果怎么显示出来呢?有三种方法:</p>\n<ul>\n<li>使用RunOnUiThread切回主线程;</li>\n<li>用handler来进行消息传递;</li>\n<li>继承AsyncTask类,在onPostExecute方法中更新UI.</li>\n</ul>\n<h3 id=\"RunOnUiThread\"><a href=\"#RunOnUiThread\" class=\"headerlink\" title=\"RunOnUiThread\"></a>RunOnUiThread</h3><p>可以把RunOnUiThread看成是一个特殊的线程,如果RunOnUiThread运行在主线程,则立即执行里面的代码,否则将Runable对象添加到消息处理队列;<br>具体事例如下:</p>\n<pre><code class=\"java\">new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //模拟耗时操作;\n                try {\n                    Thread.sleep( 2000 );\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //切回UI线程;\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        //更新UI视图;\n                    }\n                });\n            }\n        }).start();</code></pre>\n<h3 id=\"handler\"><a href=\"#handler\" class=\"headerlink\" title=\"handler\"></a>handler</h3><p>我们用handler携带message来进行子线程和主线程间的通讯,在这里我把handler看成是一个hook或者signal;<br>handler的初始化:</p>\n<pre><code class=\"java\">Handler handler=new Handler(){\n    public void handlerMessage(message msg){\n        super.handlerMessage(msg);\n        switch(msg.what){\n            case 0:\n                doSomething(msg.getData().getString(&quot;key&quot;));\n                break;\n            case 1:\n                doAnotherthing((Cast)msg.obj);\n                break;\n            default:\n        }\n    }\n};</code></pre>\n<p>在这里message的用法有两种,一种是使用<code>message.obj</code>来传递具体的数据,还有一种是把数据放在<font color=\"red\">bundle</font>里面再用<code>message.setData</code>来传递<font color=\"red\">bundle</font>.</p>\n<h4 id=\"利用message-obj来携带数据\"><a href=\"#利用message-obj来携带数据\" class=\"headerlink\" title=\"利用message.obj来携带数据\"></a>利用message.obj来携带数据</h4><pre><code class=\"java\">Message msg=Message.obtain();\nmsg.what=1;\nmsg.obj=new Cast();\nmsg.arg1=123;\nmsg.arg2=1234;\nhandler.sendMessage(msg);</code></pre>\n<h4 id=\"利用bundle来携带数据\"><a href=\"#利用bundle来携带数据\" class=\"headerlink\" title=\"利用bundle来携带数据\"></a>利用bundle来携带数据</h4><pre><code class=\"java\">Message msg=new Message();\nmsg.what=0;\nBundle bundle=new Bundle();\nbundle.putString(&quot;key&quot;,&quot;value&quot;);\nmsg.setData(bundle);\nhandler.sendMessage(msg);</code></pre>\n<h3 id=\"AsyncTask\"><a href=\"#AsyncTask\" class=\"headerlink\" title=\"AsyncTask\"></a>AsyncTask</h3><p>顾名思(si)义,AsyncTask是异步任务;它的基本用法如下:</p>\n<pre><code class=\"java\">//传入三个泛型参数,分别是: a传入给后台任务的strings, b用于显示进度条, c返回结果;\nclass Task extends AsyncTask&lt;String,String,String&gt;{\n    @Override\n    protected void onPreExecute(){\n    }\n    @Override\n    protected void doInBackground(String... strings){\n\n    }\n    @Override\n    protected void postExecute(String string){\n\n    }\n}</code></pre>\n<ul>\n<li><code>onPreExecute()</code>中进行UI界面的初始化工作,列如显示进度条或onloading的Gif动画;<img src=\"/assets/blogimg/2019-02-14.png\" width=\"30%\" alt=\"onloading\"></li>\n<li><code>doInBackground()</code>中处理耗时操作,不能进行UI操作;</li>\n<li><code>postExecute()</code>中后台任务执行完后要进行的事,列如提关闭进度条或显示任务执行结果.</li>\n</ul>\n<hr>\n<p>关于AsyncTask的更多信息请参考郭霖老师的&lt;&lt;第二行代码&gt;&gt;第十章第二节.</p>\n","more":"<p><img src=\"/assets/blogimg/andy-lg.png\" alt=\"banner\"></p>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>众所周知,android只能在主线程中更新UI视图,而一些诸如网络请求,socket通讯和Json解析之类比较耗时的操作一般放在子线程(用线程池来管理便于回收)中处理,否则会阻塞(zu se)UI线程.那么子线程中处理的结果怎么显示出来呢?有三种方法:</p>\n<ul>\n<li>使用RunOnUiThread切回主线程;</li>\n<li>用handler来进行消息传递;</li>\n<li>继承AsyncTask类,在onPostExecute方法中更新UI.</li>\n</ul>\n<h3 id=\"RunOnUiThread\"><a href=\"#RunOnUiThread\" class=\"headerlink\" title=\"RunOnUiThread\"></a>RunOnUiThread</h3><p>可以把RunOnUiThread看成是一个特殊的线程,如果RunOnUiThread运行在主线程,则立即执行里面的代码,否则将Runable对象添加到消息处理队列;<br>具体事例如下:</p>\n<pre><code class=\"java\">new Thread(new Runnable() {\n            @Override\n            public void run() {\n                //模拟耗时操作;\n                try {\n                    Thread.sleep( 2000 );\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //切回UI线程;\n                runOnUiThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        //更新UI视图;\n                    }\n                });\n            }\n        }).start();</code></pre>\n<h3 id=\"handler\"><a href=\"#handler\" class=\"headerlink\" title=\"handler\"></a>handler</h3><p>我们用handler携带message来进行子线程和主线程间的通讯,在这里我把handler看成是一个hook或者signal;<br>handler的初始化:</p>\n<pre><code class=\"java\">Handler handler=new Handler(){\n    public void handlerMessage(message msg){\n        super.handlerMessage(msg);\n        switch(msg.what){\n            case 0:\n                doSomething(msg.getData().getString(&quot;key&quot;));\n                break;\n            case 1:\n                doAnotherthing((Cast)msg.obj);\n                break;\n            default:\n        }\n    }\n};</code></pre>\n<p>在这里message的用法有两种,一种是使用<code>message.obj</code>来传递具体的数据,还有一种是把数据放在<font color=\"red\">bundle</font>里面再用<code>message.setData</code>来传递<font color=\"red\">bundle</font>.</p>\n<h4 id=\"利用message-obj来携带数据\"><a href=\"#利用message-obj来携带数据\" class=\"headerlink\" title=\"利用message.obj来携带数据\"></a>利用message.obj来携带数据</h4><pre><code class=\"java\">Message msg=Message.obtain();\nmsg.what=1;\nmsg.obj=new Cast();\nmsg.arg1=123;\nmsg.arg2=1234;\nhandler.sendMessage(msg);</code></pre>\n<h4 id=\"利用bundle来携带数据\"><a href=\"#利用bundle来携带数据\" class=\"headerlink\" title=\"利用bundle来携带数据\"></a>利用bundle来携带数据</h4><pre><code class=\"java\">Message msg=new Message();\nmsg.what=0;\nBundle bundle=new Bundle();\nbundle.putString(&quot;key&quot;,&quot;value&quot;);\nmsg.setData(bundle);\nhandler.sendMessage(msg);</code></pre>\n<h3 id=\"AsyncTask\"><a href=\"#AsyncTask\" class=\"headerlink\" title=\"AsyncTask\"></a>AsyncTask</h3><p>顾名思(si)义,AsyncTask是异步任务;它的基本用法如下:</p>\n<pre><code class=\"java\">//传入三个泛型参数,分别是: a传入给后台任务的strings, b用于显示进度条, c返回结果;\nclass Task extends AsyncTask&lt;String,String,String&gt;{\n    @Override\n    protected void onPreExecute(){\n    }\n    @Override\n    protected void doInBackground(String... strings){\n\n    }\n    @Override\n    protected void postExecute(String string){\n\n    }\n}</code></pre>\n<ul>\n<li><code>onPreExecute()</code>中进行UI界面的初始化工作,列如显示进度条或onloading的Gif动画;<img src=\"/assets/blogimg/2019-02-14.png\" width=\"30%\" alt=\"onloading\"></li>\n<li><code>doInBackground()</code>中处理耗时操作,不能进行UI操作;</li>\n<li><code>postExecute()</code>中后台任务执行完后要进行的事,列如提关闭进度条或显示任务执行结果.</li>\n</ul>\n<hr>\n<p>关于AsyncTask的更多信息请参考郭霖老师的&lt;&lt;第二行代码&gt;&gt;第十章第二节.</p>\n","categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Android","path":"api/tags/Android.json"}]}