{"title":"数据结构和算法分析(第三版)练习","slug":"p22","date":"2019-08-23T15:31:00.000Z","updated":"2020-09-17T01:35:19.909Z","comments":true,"path":"api/articles/p22.json","excerpt":null,"covers":null,"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><h3 id=\"recursive\"><a href=\"#recursive\" class=\"headerlink\" title=\"recursive\"></a>recursive</h3><ul>\n<li>base case</li>\n<li>making progress</li>\n<li>design rule</li>\n<li>compound interst rule</li>\n</ul>\n<h3 id=\"自动装箱和拆箱\"><a href=\"#自动装箱和拆箱\" class=\"headerlink\" title=\"自动装箱和拆箱\"></a>自动装箱和拆箱</h3><pre><code class=\"java\">class BoxingDemo{\n    public static void main(String[] args) {\n        // Cell类中的set方法传入的是Object类型\n        Cell&lt;Integer&gt; c=new Cell&lt;&gt;();\n        c.set(37);\n        int val=c.get();\n        System.out.println(val+&quot;&quot;);\n    }\n}</code></pre>\n<h3 id=\"java5中的通配符-wildcard\"><a href=\"#java5中的通配符-wildcard\" class=\"headerlink\" title=\"java5中的通配符(wildcard)\"></a>java5中的<strong>通配符</strong>(wildcard)</h3><pre><code class=\"java\">/*可以传入Shape类型或者它的子类Square*/\npublic static double totalArea(Collection&lt;? extends Shape&gt; arr){\n    double total=0;\n    for (Shape s : arr) {\n        if (s!=null) {\n            total+=s.area();\n        }\n        return total;\n    }\n}</code></pre>\n<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><pre><code class=\"java\">public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt;  int binarySearch(AnyType[] a,AnyType x){\n    int low=0,high=a.length-1;\n    while(low&lt;=high){\n        int mid=(low+high)/2;\n        if(a[mid].compareTo(x)&lt;0){\n            low=mid+1;\n        }else if(a[mid].compareTo(x)&gt;0){\n            high=mid-1;\n        }else{\n            return mid;\n        }\n    }\n    return -1;\n}</code></pre>\n<h3 id=\"ADT-abstract-data-type\"><a href=\"#ADT-abstract-data-type\" class=\"headerlink\" title=\"ADT(abstract data type)\"></a>ADT(abstract data type)</h3><pre><code>是带有一组操作的一些对象的集合.抽象数据类型是数学的抽象(表,集合,图);</code></pre>\n<h4 id=\"Iterator接口\"><a href=\"#Iterator接口\" class=\"headerlink\" title=\"Iterator接口\"></a>Iterator接口</h4><pre><code class=\"java\">public static&lt;AnyType&gt; void print(Collection&lt;AnyType&gt; coll){\n    Iterator&lt;AnyType&gt; itr=coll.iterator();\n    while(itr.hasNext()){\n        AnyType item=itr.next();\n        System.out.println(item);\n    }\n}</code></pre>\n<h4 id=\"List接口-ArrayList-LinkedList\"><a href=\"#List接口-ArrayList-LinkedList\" class=\"headerlink\" title=\"List接口(ArrayList,LinkedList)\"></a>List接口(ArrayList,LinkedList)</h4><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">ArrayList</th>\n<th align=\"left\">LinkedList</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">实现</td>\n<td align=\"left\">可增长的数组</td>\n<td align=\"left\">双链表</td>\n</tr>\n<tr>\n<td align=\"left\">优点</td>\n<td align=\"left\">get&amp;set耗费常数级的时间</td>\n<td align=\"left\">在现有表进行删除和插入都是常数级的耗时</td>\n</tr>\n<tr>\n<td align=\"left\">缺点</td>\n<td align=\"left\">新项的插入和现有项的删除代价昂贵,除非是在末端</td>\n<td align=\"left\">由于不容易做索引,因此对get的调用时昂贵的O(N)</td>\n</tr>\n</tbody></table>\n<p><em>tips:</em></p>\n<ul>\n<li>LinkedList常用方法:addFirst,removeFist,addLast,removeLast,getFirst,getLast;</li>\n</ul>\n","more":"<h3 id=\"recursive\"><a href=\"#recursive\" class=\"headerlink\" title=\"recursive\"></a>recursive</h3><ul>\n<li>base case</li>\n<li>making progress</li>\n<li>design rule</li>\n<li>compound interst rule</li>\n</ul>\n<h3 id=\"自动装箱和拆箱\"><a href=\"#自动装箱和拆箱\" class=\"headerlink\" title=\"自动装箱和拆箱\"></a>自动装箱和拆箱</h3><pre><code class=\"java\">class BoxingDemo{\n    public static void main(String[] args) {\n        // Cell类中的set方法传入的是Object类型\n        Cell&lt;Integer&gt; c=new Cell&lt;&gt;();\n        c.set(37);\n        int val=c.get();\n        System.out.println(val+&quot;&quot;);\n    }\n}</code></pre>\n<h3 id=\"java5中的通配符-wildcard\"><a href=\"#java5中的通配符-wildcard\" class=\"headerlink\" title=\"java5中的通配符(wildcard)\"></a>java5中的<strong>通配符</strong>(wildcard)</h3><pre><code class=\"java\">/*可以传入Shape类型或者它的子类Square*/\npublic static double totalArea(Collection&lt;? extends Shape&gt; arr){\n    double total=0;\n    for (Shape s : arr) {\n        if (s!=null) {\n            total+=s.area();\n        }\n        return total;\n    }\n}</code></pre>\n<h3 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h3><pre><code class=\"java\">public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt;  int binarySearch(AnyType[] a,AnyType x){\n    int low=0,high=a.length-1;\n    while(low&lt;=high){\n        int mid=(low+high)/2;\n        if(a[mid].compareTo(x)&lt;0){\n            low=mid+1;\n        }else if(a[mid].compareTo(x)&gt;0){\n            high=mid-1;\n        }else{\n            return mid;\n        }\n    }\n    return -1;\n}</code></pre>\n<h3 id=\"ADT-abstract-data-type\"><a href=\"#ADT-abstract-data-type\" class=\"headerlink\" title=\"ADT(abstract data type)\"></a>ADT(abstract data type)</h3><pre><code>是带有一组操作的一些对象的集合.抽象数据类型是数学的抽象(表,集合,图);</code></pre>\n<h4 id=\"Iterator接口\"><a href=\"#Iterator接口\" class=\"headerlink\" title=\"Iterator接口\"></a>Iterator接口</h4><pre><code class=\"java\">public static&lt;AnyType&gt; void print(Collection&lt;AnyType&gt; coll){\n    Iterator&lt;AnyType&gt; itr=coll.iterator();\n    while(itr.hasNext()){\n        AnyType item=itr.next();\n        System.out.println(item);\n    }\n}</code></pre>\n<h4 id=\"List接口-ArrayList-LinkedList\"><a href=\"#List接口-ArrayList-LinkedList\" class=\"headerlink\" title=\"List接口(ArrayList,LinkedList)\"></a>List接口(ArrayList,LinkedList)</h4><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">ArrayList</th>\n<th align=\"left\">LinkedList</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">实现</td>\n<td align=\"left\">可增长的数组</td>\n<td align=\"left\">双链表</td>\n</tr>\n<tr>\n<td align=\"left\">优点</td>\n<td align=\"left\">get&amp;set耗费常数级的时间</td>\n<td align=\"left\">在现有表进行删除和插入都是常数级的耗时</td>\n</tr>\n<tr>\n<td align=\"left\">缺点</td>\n<td align=\"left\">新项的插入和现有项的删除代价昂贵,除非是在末端</td>\n<td align=\"left\">由于不容易做索引,因此对get的调用时昂贵的O(N)</td>\n</tr>\n</tbody></table>\n<p><em>tips:</em></p>\n<ul>\n<li>LinkedList常用方法:addFirst,removeFist,addLast,removeLast,getFirst,getLast;</li>\n</ul>\n","categories":[{"name":"notebook","path":"api/categories/notebook.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"reading book","path":"api/tags/reading book.json"}]}