{"title":"官网信息更新获得通知","slug":"get-website-message-alert","date":"2020-03-10T04:19:53.000Z","updated":"2020-09-02T17:08:42.674Z","comments":true,"path":"api/articles/get-website-message-alert.json","excerpt":null,"covers":["/assets/blogimg/example_2020-03-10.jpg"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>国家线还没出, 众多2020考研学子们一定异常焦急地等待官网的通告, 想着复试名单什么时候出, 但又不能时时刻刻盯着官网的通知栏; 别担心, 让代码来帮助你…<br>我们需要代码帮我们完成这样几件事:</p>\n<ol>\n<li>每隔10min检查一下官网的通知栏</li>\n<li>抓取第一条通知</li>\n<li>将抓取到的通知与上一条抓取的通知比对<ul>\n<li>如果不相同则将这次的通知发送到用户的手机上, 将上一条通告覆盖并重复以上步骤</li>\n<li>如果相同则不进行操作, 重复以上三个步骤</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"jsoup\"><a href=\"#jsoup\" class=\"headerlink\" title=\"jsoup\"></a>jsoup</h3><blockquote>\n<p>jsoup is a Java library for working with real-world HTML. It provides a very convenient API for fetching URLs and extracting and manipulating data, using the best of HTML5 DOM methods and CSS selectors.</p>\n</blockquote>\n<p>jsoup是一个HTML解析器, 他能像CSS选择器一样选取DOM节点, 做到类似于XPath的效果;</p>\n<p>使用jsoup获得网页内容就一句话<code>Document doc = Jsoup.connect(TARGET_URL).get();</code><br><img src=\"/assets/blogimg/example_2020-03-10.jpg\" alt=\"example\"><br>如何选到<code>&lt;a&gt;</code>标签中的Text呢?</p>\n<ol>\n<li>先获取到它们的父级标签<code>&lt;td class=&quot;tablexu&quot;&gt;</code><pre><code class=\"java\">Element element = doc.select(&quot;td.tablexu&quot;).first();</code></pre>\n</li>\n<li>在<code>&lt;a&gt;</code>标签所组成的集合里面选取第一个标签并获取标签内的文字, 也就是最新的通告<pre><code class=\"java\">String newMsg=element.select(&quot;a&quot;).first().text();</code></pre>\n</li>\n</ol>\n<h3 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h3><p><strong>Timer</strong>是javaAPI中的一个定时器, 它能每隔一段时间开启一个子线程处理任务(C#中也有类似的API);</p>\n<p>java代码如下:</p>\n<pre><code class=\"java\">import org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class Main {\n    public final static String TARGET_URL=&quot;http://jky.yangtzeu.edu.cn/tzgg.htm&quot;;\n    public final static String TARGET_URL2=&quot;http://yjsc.yangtzeu.edu.cn/zsgz/tzgg.htm&quot;;\n    public final static String MSG_URL;\n\n    private static String oldMsg=&quot;&quot;;\n    public static void main(String[] args) {\n        Timer timer=new Timer();\n        timer.schedule(new FooTimerTask(),1000,1000*60*10);\n    }\n    static class FooTimerTask extends TimerTask {\n        @Override\n        public void run() {\n            try {\n                Document doc = Jsoup.connect(TARGET_URL2).get();\n                Element element = doc.select(&quot;td.tablexu&quot;).first();\n                String newMsg=element.select(&quot;a&quot;).first().text();\n                if (!newMsg.equals(oldMsg)){\n                    System.out.println(newMsg);\n                    System.out.println(sendGet(MSG_URL+&quot;?text=&quot;+newMsg.replace(&quot; &quot;,&quot;&quot;)+&quot;&amp;desp=[点击这里](http://yjsc.yangtzeu.edu.cn/&quot;+element.select(&quot;a&quot;).attr(&quot;href&quot;).replace(&quot;..&quot;,&quot;&quot;)+&quot;)&quot;));\n                    oldMsg=newMsg;\n                }\n            }catch(Exception e) {\n                System.err.println(sendGet(MSG_URL+&quot;?text=get website message failed!!!&amp;desep=&quot;+e.getMessage()));\n            }\n        }\n    }\n\n    public static String sendGet(String urlName){\n        String result = &quot;&quot;;\n        try{\n            URL realUrl = new URL(urlName);\n            URLConnection conn = realUrl.openConnection();\n            conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);\n            conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);\n            conn.setRequestProperty(&quot;user-agent&quot;,\n                    &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);\n            conn.connect();\n            Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();\n            for (String key : map.keySet()) {\n                System.out.println(key + &quot;--&gt;&quot; + map.get(key));\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n        } catch (Exception e) {\n            System.out.println(&quot;get request failed!!&quot; + e);\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n</code></pre>\n<h3 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h3><ul>\n<li>怎么把通知发送到手机上?<ul>\n<li>可以借助于微信或者QQ的API(我用的是Server酱)</li>\n<li>可以用做一个AndroidAPP用Socket和部署在服务器上的脚本建立连接;</li>\n</ul>\n</li>\n<li>怎么部署<ul>\n<li>将项目打包成可执行的jar包扔到装有JDK的服务器上运行</li>\n<li>服务器甚至不需要开放相应的端口(省去了很多麻烦)</li>\n</ul>\n</li>\n</ul>\n","more":"<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a>background</h3><p>国家线还没出, 众多2020考研学子们一定异常焦急地等待官网的通告, 想着复试名单什么时候出, 但又不能时时刻刻盯着官网的通知栏; 别担心, 让代码来帮助你…<br>我们需要代码帮我们完成这样几件事:</p>\n<ol>\n<li>每隔10min检查一下官网的通知栏</li>\n<li>抓取第一条通知</li>\n<li>将抓取到的通知与上一条抓取的通知比对<ul>\n<li>如果不相同则将这次的通知发送到用户的手机上, 将上一条通告覆盖并重复以上步骤</li>\n<li>如果相同则不进行操作, 重复以上三个步骤</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"jsoup\"><a href=\"#jsoup\" class=\"headerlink\" title=\"jsoup\"></a>jsoup</h3><blockquote>\n<p>jsoup is a Java library for working with real-world HTML. It provides a very convenient API for fetching URLs and extracting and manipulating data, using the best of HTML5 DOM methods and CSS selectors.</p>\n</blockquote>\n<p>jsoup是一个HTML解析器, 他能像CSS选择器一样选取DOM节点, 做到类似于XPath的效果;</p>\n<p>使用jsoup获得网页内容就一句话<code>Document doc = Jsoup.connect(TARGET_URL).get();</code><br><img src=\"/assets/blogimg/example_2020-03-10.jpg\" alt=\"example\"><br>如何选到<code>&lt;a&gt;</code>标签中的Text呢?</p>\n<ol>\n<li>先获取到它们的父级标签<code>&lt;td class=&quot;tablexu&quot;&gt;</code><pre><code class=\"java\">Element element = doc.select(&quot;td.tablexu&quot;).first();</code></pre>\n</li>\n<li>在<code>&lt;a&gt;</code>标签所组成的集合里面选取第一个标签并获取标签内的文字, 也就是最新的通告<pre><code class=\"java\">String newMsg=element.select(&quot;a&quot;).first().text();</code></pre>\n</li>\n</ol>\n<h3 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h3><p><strong>Timer</strong>是javaAPI中的一个定时器, 它能每隔一段时间开启一个子线程处理任务(C#中也有类似的API);</p>\n<p>java代码如下:</p>\n<pre><code class=\"java\">import org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\npublic class Main {\n    public final static String TARGET_URL=&quot;http://jky.yangtzeu.edu.cn/tzgg.htm&quot;;\n    public final static String TARGET_URL2=&quot;http://yjsc.yangtzeu.edu.cn/zsgz/tzgg.htm&quot;;\n    public final static String MSG_URL;\n\n    private static String oldMsg=&quot;&quot;;\n    public static void main(String[] args) {\n        Timer timer=new Timer();\n        timer.schedule(new FooTimerTask(),1000,1000*60*10);\n    }\n    static class FooTimerTask extends TimerTask {\n        @Override\n        public void run() {\n            try {\n                Document doc = Jsoup.connect(TARGET_URL2).get();\n                Element element = doc.select(&quot;td.tablexu&quot;).first();\n                String newMsg=element.select(&quot;a&quot;).first().text();\n                if (!newMsg.equals(oldMsg)){\n                    System.out.println(newMsg);\n                    System.out.println(sendGet(MSG_URL+&quot;?text=&quot;+newMsg.replace(&quot; &quot;,&quot;&quot;)+&quot;&amp;desp=[点击这里](http://yjsc.yangtzeu.edu.cn/&quot;+element.select(&quot;a&quot;).attr(&quot;href&quot;).replace(&quot;..&quot;,&quot;&quot;)+&quot;)&quot;));\n                    oldMsg=newMsg;\n                }\n            }catch(Exception e) {\n                System.err.println(sendGet(MSG_URL+&quot;?text=get website message failed!!!&amp;desep=&quot;+e.getMessage()));\n            }\n        }\n    }\n\n    public static String sendGet(String urlName){\n        String result = &quot;&quot;;\n        try{\n            URL realUrl = new URL(urlName);\n            URLConnection conn = realUrl.openConnection();\n            conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);\n            conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);\n            conn.setRequestProperty(&quot;user-agent&quot;,\n                    &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);\n            conn.connect();\n            Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();\n            for (String key : map.keySet()) {\n                System.out.println(key + &quot;--&gt;&quot; + map.get(key));\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            while ((line = in.readLine()) != null) {\n                result += line;\n            }\n        } catch (Exception e) {\n            System.out.println(&quot;get request failed!!&quot; + e);\n            e.printStackTrace();\n        }\n        return result;\n    }\n}\n</code></pre>\n<h3 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h3><ul>\n<li>怎么把通知发送到手机上?<ul>\n<li>可以借助于微信或者QQ的API(我用的是Server酱)</li>\n<li>可以用做一个AndroidAPP用Socket和部署在服务器上的脚本建立连接;</li>\n</ul>\n</li>\n<li>怎么部署<ul>\n<li>将项目打包成可执行的jar包扔到装有JDK的服务器上运行</li>\n<li>服务器甚至不需要开放相应的端口(省去了很多麻烦)</li>\n</ul>\n</li>\n</ul>\n","categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"}]}