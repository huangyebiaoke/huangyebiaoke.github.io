{"title":"<算法第四版>最佳实践","slug":"algorithms-fourth-edition-best-practice","date":"2019-06-29T19:12:11.000Z","updated":"2020-08-31T21:43:29.549Z","comments":true,"path":"api/articles/algorithms-fourth-edition-best-practice.json","excerpt":null,"covers":["/assets/blogimg/sort-algorithm-banner.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><p><img src=\"/assets/blogimg/sort-algorithm-banner.png\" alt=\"sort-algorithm\"></p>\n<h3 id=\"bucket-sort\"><a href=\"#bucket-sort\" class=\"headerlink\" title=\"bucket sort\"></a>bucket sort</h3><p><strong>桶排序</strong>的基本思路是遍历一个待排的数组,把每个数出现的次数记录到一个新的数组里面,那这个新的数组里的下标就是待排序的数组的值.</p>\n<p>设待排数组是arr,记录待排数组的桶是bucket让我们来理一下思路:</p>\n<ol>\n<li>新建一个数组,数组的大小是arr.length-1;</li>\n<li>循环遍历arr这个数组,在循环体里面将arr数出现的次数记录到bucket这个数组里面;</li>\n<li>遍历bucket这个数组,判断值是多少就输出多少次bucket的下标;</li>\n</ol>\n<p>以下是Java代码:</p>\n<pre><code class=\"java\">public static void bucketSort(int [] arr){\n        int[] bucket=new int[max(arr)+1];\n        for (int i = 0; i &lt; arr.length; i++) {\n            bucket[arr[i]]++;\n        }\n        int count=0;\n        for (int i=0;i&lt;bucket.length;i++){\n            for (int j = 1; j &lt;= bucket[i]; j++) {\n                arr[count++]=i;\n            }\n        }\n    }</code></pre>\n<p>以上只是一个简单的桶排序,<em>不能排序负数和小数</em>,但它的时间复杂度也仅仅是<code>T(N)=O(N+M)</code>;</p>\n<h3 id=\"buble-sort\"><a href=\"#buble-sort\" class=\"headerlink\" title=\"buble sort\"></a>buble sort</h3><p><strong>冒泡排序</strong>的的思路就是遍历数组,交换(<em>swap</em>)相邻两个元素,使余下未排序数组部分最大(或最小)的元素浮到最前或最后;<br>这样排序一个长度为N的数组所需要的时间复杂度<code>T(N)=O(N&lt;sup&gt;2&lt;/sup&gt;)</code></p>\n<p>以下是java代码:</p>\n<pre><code class=\"java\">    public static void bubbleSort(int [] arr){\n        for (int i = arr.length; i &gt; 0; i--) {\n            for (int j = 0; j &lt; i-1; j++) {\n                if (arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }</code></pre>\n<p>冒泡排序的缺点很明显,在全部无序的情况下,时间复杂度太高了(因为它只能交换相邻两个元素);<br>而且上述的示例有一个需要改进的地方就是:设想一个数组前半部分是有序的,但是如果有序的话检查一次就够了(前面在排序后半部分的元素中已经检查过了),所以我们可以设一个布尔型的flag值,有序就直接跳过,这样能大大缩短代码运行时间;</p>\n<h3 id=\"selection-sort\"><a href=\"#selection-sort\" class=\"headerlink\" title=\"selection sort\"></a>selection sort</h3><p><strong>选择排序</strong>和冒泡排序有点类似,它的基本思路就是把数组看成两部分:一部分有序,一部分无序;<br>把后面无序的部分的最小值放到前半部分的最后面(<em>冒泡排序是交换相邻的元素</em>)</p>\n<p>以下是java代码:</p>\n<pre><code class=\"java\">    public static void selectionSort(int[] arr){\n        for (int i = 0; i &lt; arr.length; i++) {\n            for (int j = i+1; j &lt; arr.length; j++) {\n                if (arr[j]&lt;arr[i]){\n                    swap(arr,j,i);\n                }\n            }\n        }\n    }</code></pre>\n<p>选择排序的时间复杂度也是<code>O(N&lt;sup&gt;2&lt;/sup&gt;)</code></p>\n<h3 id=\"insertion-sort\"><a href=\"#insertion-sort\" class=\"headerlink\" title=\"insertion sort\"></a>insertion sort</h3><p><strong>插入排序</strong>的基本思路是选择后面没排序的部分的第一个元素,插入到前半部分有序的合适位置(和选择排序正好相反);</p>\n<p><em>让我们来理一下思路吧:</em></p>\n<ol>\n<li>arr[0]是有序的;</li>\n<li>遍历余下的将arr[1]放到前面有序部分的合适位置(arr[0]前面或后面);</li>\n<li>每次把余下部分的第一个放到前面有序的合适位置(重复1,2步骤);</li>\n<li>直到余下的部分没有元素.</li>\n</ol>\n<p>以下是java代码:</p>\n<pre><code class=\"java\">    /**\n     * thought the arr as two part, the front part is ordered and the end part is unordered;\n     * in the loop each time put the fist element of the end part to the appropriate position in the front part;\n     * until the outer loop is over;\n     * @param arr the array wait to sort;\n     */\n    public static void insertionSort(int[] arr){\n        for (int i = 0; i &lt; arr.length; i++) {\n            for (int j = 0; j &lt; i; j++) {\n                if (arr[i]&lt;arr[j]){\n                    int tmp=arr[i];\n                    for (int k = i; k &gt; j; k--) {\n                        arr[k]=arr[k-1];\n                    }\n                    arr[j]=tmp;\n                    break;\n                }\n            }\n        }\n    }</code></pre>\n<p>由于有两层循环,所以它的时间复杂度也是<code>O(N&lt;sup&gt;2&lt;/sup&gt;)</code>,不过和选择排序不同的是它是<em>稳定的排序</em>;</p>\n<h3 id=\"quick-sort\"><a href=\"#quick-sort\" class=\"headerlink\" title=\"quick sort\"></a>quick sort</h3><p><strong>快速排序</strong>采用分治法(<em>divide-and-conquer method</em>),利用递归(<em>recursion</em>)对数组作拆分处理;<br>分治法的基本思路就是:大事化小,小事化无;</p>\n<p>让我们来理一下思路吧:</p>\n<ol>\n<li>随便找一个元素看作基准点(为了方便起见我们不妨把arr[0]看作基准点);</li>\n<li>基准点左边的数比基准点小,右边的数比它大;</li>\n<li>循环调用,直到每部分只有两数,左边小,右边大;</li>\n</ol>\n<p>java代码如下:</p>\n<pre><code class=\"java\">    /**\n     * &lt;quote&gt;Quicksort is a divide-and-conquer method for sorting.&lt;/quote&gt;\n     * divide the arr to two parts, set the leftest element as the standard position;\n     * find the smaller element than standard position from the right;\n     * find the larger element than standard position from the left;\n     * @param arr the arr wait to sort\n     * @param left left guard\n     * @param right right guard\n     */\n    public static void quickSort(int[] arr,int left,int right){\n        if (left&gt;right) return;\n        int i=left,j=right,pos=arr[left];\n        while(i!=j){\n            while(i&lt;j&amp;&amp;arr[j]&gt;=pos){\n                j--;\n            }\n            while(i&lt;j&amp;&amp;arr[i]&lt;=pos){\n                i++;\n            }\n            if (i&lt;j){\n                swap(arr,i,j);\n            }\n        }\n        arr[left]=arr[i];\n        arr[i]=pos;\n        quickSort(arr,left,i-1);\n        quickSort(arr,i+1,right);\n    }</code></pre>\n<p>由于快排是跳跃交换元素位置的(和冒泡排序不同),所以它的平均时间复杂度是<code>O(NlogN)</code>;<br>没接触到递归的同学可能觉得快排有点抽象,可以参照&lt;啊哈,算法&gt;或&lt;算法第四版&gt;(实际上我也在用这两本教材),你也可以看看发明者关于快排的论文;</p>\n<h3 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h3><p>以下是每种算法的平均时间复杂度:</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>T(N)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bucket sort</td>\n<td>O(N+M)</td>\n</tr>\n<tr>\n<td>buble sort</td>\n<td>O(N<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>selection sort</td>\n<td>O(N<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>insertion sort</td>\n<td>O(N<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>quick sort</td>\n<td>O(NlogN)</td>\n</tr>\n</tbody></table>\n<p>还有其他的希尔排序,堆排序,计数排序,基数排序啊有待同学们去一一探索,这里就不再一一赘述了.</p>\n","more":"<p><img src=\"/assets/blogimg/sort-algorithm-banner.png\" alt=\"sort-algorithm\"></p>\n<h3 id=\"bucket-sort\"><a href=\"#bucket-sort\" class=\"headerlink\" title=\"bucket sort\"></a>bucket sort</h3><p><strong>桶排序</strong>的基本思路是遍历一个待排的数组,把每个数出现的次数记录到一个新的数组里面,那这个新的数组里的下标就是待排序的数组的值.</p>\n<p>设待排数组是arr,记录待排数组的桶是bucket让我们来理一下思路:</p>\n<ol>\n<li>新建一个数组,数组的大小是arr.length-1;</li>\n<li>循环遍历arr这个数组,在循环体里面将arr数出现的次数记录到bucket这个数组里面;</li>\n<li>遍历bucket这个数组,判断值是多少就输出多少次bucket的下标;</li>\n</ol>\n<p>以下是Java代码:</p>\n<pre><code class=\"java\">public static void bucketSort(int [] arr){\n        int[] bucket=new int[max(arr)+1];\n        for (int i = 0; i &lt; arr.length; i++) {\n            bucket[arr[i]]++;\n        }\n        int count=0;\n        for (int i=0;i&lt;bucket.length;i++){\n            for (int j = 1; j &lt;= bucket[i]; j++) {\n                arr[count++]=i;\n            }\n        }\n    }</code></pre>\n<p>以上只是一个简单的桶排序,<em>不能排序负数和小数</em>,但它的时间复杂度也仅仅是<code>T(N)=O(N+M)</code>;</p>\n<h3 id=\"buble-sort\"><a href=\"#buble-sort\" class=\"headerlink\" title=\"buble sort\"></a>buble sort</h3><p><strong>冒泡排序</strong>的的思路就是遍历数组,交换(<em>swap</em>)相邻两个元素,使余下未排序数组部分最大(或最小)的元素浮到最前或最后;<br>这样排序一个长度为N的数组所需要的时间复杂度<code>T(N)=O(N&lt;sup&gt;2&lt;/sup&gt;)</code></p>\n<p>以下是java代码:</p>\n<pre><code class=\"java\">    public static void bubbleSort(int [] arr){\n        for (int i = arr.length; i &gt; 0; i--) {\n            for (int j = 0; j &lt; i-1; j++) {\n                if (arr[j]&gt;arr[j+1]){\n                    swap(arr,j,j+1);\n                }\n            }\n        }\n    }</code></pre>\n<p>冒泡排序的缺点很明显,在全部无序的情况下,时间复杂度太高了(因为它只能交换相邻两个元素);<br>而且上述的示例有一个需要改进的地方就是:设想一个数组前半部分是有序的,但是如果有序的话检查一次就够了(前面在排序后半部分的元素中已经检查过了),所以我们可以设一个布尔型的flag值,有序就直接跳过,这样能大大缩短代码运行时间;</p>\n<h3 id=\"selection-sort\"><a href=\"#selection-sort\" class=\"headerlink\" title=\"selection sort\"></a>selection sort</h3><p><strong>选择排序</strong>和冒泡排序有点类似,它的基本思路就是把数组看成两部分:一部分有序,一部分无序;<br>把后面无序的部分的最小值放到前半部分的最后面(<em>冒泡排序是交换相邻的元素</em>)</p>\n<p>以下是java代码:</p>\n<pre><code class=\"java\">    public static void selectionSort(int[] arr){\n        for (int i = 0; i &lt; arr.length; i++) {\n            for (int j = i+1; j &lt; arr.length; j++) {\n                if (arr[j]&lt;arr[i]){\n                    swap(arr,j,i);\n                }\n            }\n        }\n    }</code></pre>\n<p>选择排序的时间复杂度也是<code>O(N&lt;sup&gt;2&lt;/sup&gt;)</code></p>\n<h3 id=\"insertion-sort\"><a href=\"#insertion-sort\" class=\"headerlink\" title=\"insertion sort\"></a>insertion sort</h3><p><strong>插入排序</strong>的基本思路是选择后面没排序的部分的第一个元素,插入到前半部分有序的合适位置(和选择排序正好相反);</p>\n<p><em>让我们来理一下思路吧:</em></p>\n<ol>\n<li>arr[0]是有序的;</li>\n<li>遍历余下的将arr[1]放到前面有序部分的合适位置(arr[0]前面或后面);</li>\n<li>每次把余下部分的第一个放到前面有序的合适位置(重复1,2步骤);</li>\n<li>直到余下的部分没有元素.</li>\n</ol>\n<p>以下是java代码:</p>\n<pre><code class=\"java\">    /**\n     * thought the arr as two part, the front part is ordered and the end part is unordered;\n     * in the loop each time put the fist element of the end part to the appropriate position in the front part;\n     * until the outer loop is over;\n     * @param arr the array wait to sort;\n     */\n    public static void insertionSort(int[] arr){\n        for (int i = 0; i &lt; arr.length; i++) {\n            for (int j = 0; j &lt; i; j++) {\n                if (arr[i]&lt;arr[j]){\n                    int tmp=arr[i];\n                    for (int k = i; k &gt; j; k--) {\n                        arr[k]=arr[k-1];\n                    }\n                    arr[j]=tmp;\n                    break;\n                }\n            }\n        }\n    }</code></pre>\n<p>由于有两层循环,所以它的时间复杂度也是<code>O(N&lt;sup&gt;2&lt;/sup&gt;)</code>,不过和选择排序不同的是它是<em>稳定的排序</em>;</p>\n<h3 id=\"quick-sort\"><a href=\"#quick-sort\" class=\"headerlink\" title=\"quick sort\"></a>quick sort</h3><p><strong>快速排序</strong>采用分治法(<em>divide-and-conquer method</em>),利用递归(<em>recursion</em>)对数组作拆分处理;<br>分治法的基本思路就是:大事化小,小事化无;</p>\n<p>让我们来理一下思路吧:</p>\n<ol>\n<li>随便找一个元素看作基准点(为了方便起见我们不妨把arr[0]看作基准点);</li>\n<li>基准点左边的数比基准点小,右边的数比它大;</li>\n<li>循环调用,直到每部分只有两数,左边小,右边大;</li>\n</ol>\n<p>java代码如下:</p>\n<pre><code class=\"java\">    /**\n     * &lt;quote&gt;Quicksort is a divide-and-conquer method for sorting.&lt;/quote&gt;\n     * divide the arr to two parts, set the leftest element as the standard position;\n     * find the smaller element than standard position from the right;\n     * find the larger element than standard position from the left;\n     * @param arr the arr wait to sort\n     * @param left left guard\n     * @param right right guard\n     */\n    public static void quickSort(int[] arr,int left,int right){\n        if (left&gt;right) return;\n        int i=left,j=right,pos=arr[left];\n        while(i!=j){\n            while(i&lt;j&amp;&amp;arr[j]&gt;=pos){\n                j--;\n            }\n            while(i&lt;j&amp;&amp;arr[i]&lt;=pos){\n                i++;\n            }\n            if (i&lt;j){\n                swap(arr,i,j);\n            }\n        }\n        arr[left]=arr[i];\n        arr[i]=pos;\n        quickSort(arr,left,i-1);\n        quickSort(arr,i+1,right);\n    }</code></pre>\n<p>由于快排是跳跃交换元素位置的(和冒泡排序不同),所以它的平均时间复杂度是<code>O(NlogN)</code>;<br>没接触到递归的同学可能觉得快排有点抽象,可以参照&lt;啊哈,算法&gt;或&lt;算法第四版&gt;(实际上我也在用这两本教材),你也可以看看发明者关于快排的论文;</p>\n<h3 id=\"summary\"><a href=\"#summary\" class=\"headerlink\" title=\"summary\"></a>summary</h3><p>以下是每种算法的平均时间复杂度:</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>T(N)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bucket sort</td>\n<td>O(N+M)</td>\n</tr>\n<tr>\n<td>buble sort</td>\n<td>O(N<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>selection sort</td>\n<td>O(N<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>insertion sort</td>\n<td>O(N<sup>2</sup>)</td>\n</tr>\n<tr>\n<td>quick sort</td>\n<td>O(NlogN)</td>\n</tr>\n</tbody></table>\n<p>还有其他的希尔排序,堆排序,计数排序,基数排序啊有待同学们去一一探索,这里就不再一一赘述了.</p>\n","categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"algorithm","path":"api/tags/algorithm.json"}]}