{"title":"<算法第四版>最佳实践-优先队列","slug":"priority-queues","date":"2022-05-23T10:38:47.000Z","updated":"2022-05-23T10:50:06.351Z","comments":true,"path":"api/articles/priority-queues.json","excerpt":null,"covers":["/assets/blogimg/image-20220523163429676.png","/assets/blogimg/image-20220523172347153.png","/assets/blogimg/image-20220523175021545.png"],"content":"<link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css\"><h2 id=\"优先队列的例子\"><a href=\"#优先队列的例子\" class=\"headerlink\" title=\"优先队列的例子\"></a>优先队列的例子</h2><p>从N(数据量很大，超过内存限制)个数中找最大的M个数</p>\n<pre><code class=\"java\">MinPQ&lt;Transaction&gt; pq = new MinPQ&lt;Transaction&gt;();\nwhile (StdIn.hasNextLine())\n{\n   String line = StdIn.readLine();\n   Transaction item = new Transaction(line);\n   pq.insert(item); \n   if (pq.size() &gt; M)\n      pq.delMin();\n}</code></pre>\n<h2 id=\"二叉堆实现\"><a href=\"#二叉堆实现\" class=\"headerlink\" title=\"二叉堆实现\"></a>二叉堆实现</h2><ul>\n<li><p>大顶堆(小根堆): 左右子节点小于父节点, 右子节点小于左子节点(和排序二叉树区分)</p>\n</li>\n<li><p>完全二叉树可用数组表示, 位置k的父节点为k/2, 左右子节点分别为2k和2k+1</p>\n<img src=\"/assets/blogimg/image-20220523163429676.png\" alt=\"image-20220523163429676\" style=\"zoom:80%;\">\n\n</li>\n</ul>\n<h3 id=\"堆的有序化-reheapifying\"><a href=\"#堆的有序化-reheapifying\" class=\"headerlink\" title=\"堆的有序化(reheapifying)\"></a>堆的有序化(reheapifying)</h3><blockquote>\n<p>问题: 当插入元素大于根节点的元素时(insert), 或者删除根节点的元素时(delMax)需要对堆进行重排以保证堆是有序的大顶堆</p>\n</blockquote>\n<h4 id=\"当插入的节点比根节点更大时\"><a href=\"#当插入的节点比根节点更大时\" class=\"headerlink\" title=\"当插入的节点比根节点更大时:\"></a>当插入的节点比根节点更大时:</h4><ul>\n<li>将插入的节点和它的父节点进行交换(类似于冒泡排序中的内层循环)</li>\n<li>直到整个大顶堆有序</li>\n</ul>\n<pre><code class=\"java\">private void swim(int k)\n{\n   while (k &gt; 1 &amp;&amp; less(k/2, k))\n   {\n      exch(k, k/2);\n      k = k/2;\n   }\n}</code></pre>\n<p><img src=\"/assets/blogimg/image-20220523172347153.png\" alt=\"image-20220523172347153\"></p>\n<p><strong>插入操作:</strong> 每次插入操作都要检查二叉树是否有序, 最多花费 1 + lg N 次比较</p>\n<pre><code class=\"java\">public void insert(Key x)\n{\n   pq[++N] = x;\n   swim(N);\n}</code></pre>\n<h4 id=\"当删除根节点的元素时\"><a href=\"#当删除根节点的元素时\" class=\"headerlink\" title=\"当删除根节点的元素时:\"></a>当删除根节点的元素时:</h4><ul>\n<li>将根节点和尾节点(数组最后一个元素)交换并删除尾节点;</li>\n<li>自上而下调整根节点中元素的位置</li>\n</ul>\n<p><strong>删除根节点操作:</strong></p>\n<pre><code class=\"java\">public Key delMax()\n{\n   Key max = pq[1];//记录要删除的根节点\n   exch(1, N--);//根节点和数组最后的元素交换, 然后删除数组最后一个元素\n   sink(1);//从上而下调整时使堆有序\n   pq[N+1] = null;//数组最后一个元素置为null使之能够被GC回收(防止游离)\n   return max;//返回删除的元素\n}</code></pre>\n<p><strong>自上而下调整:</strong></p>\n<ul>\n<li>将较小的根节点元素和子节点中较大的元素交换</li>\n<li>直到大顶堆有序</li>\n</ul>\n<pre><code class=\"java\">private void sink(int k)\n{\n   while (2*k &lt;= N)\n   {\n      int j = 2*k;\n      //交换子节点中的较大者\n      if (j &lt; N &amp;&amp; less(j, j+1)) j++;\n      if (!less(k, j)) break;\n      exch(k, j);\n      k = j;\n   }\n}</code></pre>\n<p><img src=\"/assets/blogimg/image-20220523175021545.png\" alt=\"image-20220523175021545\"></p>\n<h2 id=\"优先队列实现代码\"><a href=\"#优先队列实现代码\" class=\"headerlink\" title=\"优先队列实现代码\"></a>优先队列实现代码</h2><pre><code class=\"java\">public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;\n{\n   private Key[] pq;\n   private int N;\n   public MaxPQ(int capacity)\n   {  pq = (Key[]) new Comparable[capacity+1];  }\n   public boolean isEmpty()\n   {   return N == 0;   }\n   public void insert(Key key)\n   public Key delMax()\n   {   /* see previous code */  }\n   private void swim(int k)\n   private void sink(int k)\n   {   /* see previous code */  }\n   private boolean less(int i, int j)\n   {   return pq[i].compareTo(pq[j]) &lt; 0;  }\n   private void exch(int i, int j)\n   {   Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;  }\n}</code></pre>\n<table>\n<thead>\n<tr>\n<th>实现方式</th>\n<th>插入</th>\n<th>删除堆顶元素</th>\n<th>查找堆顶元素</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无序数组</td>\n<td>1</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>有序数组</td>\n<td>N</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td><strong>大顶堆</strong></td>\n<td><strong>logN</strong></td>\n<td><strong>logN</strong></td>\n<td><strong>1</strong></td>\n</tr>\n<tr>\n<td>d-ary heap</td>\n<td>log<del>d</del>N</td>\n<td>d*log<del>d</del>N</td>\n<td>1</td>\n</tr>\n</tbody></table>\n","more":"<h2 id=\"优先队列的例子\"><a href=\"#优先队列的例子\" class=\"headerlink\" title=\"优先队列的例子\"></a>优先队列的例子</h2><p>从N(数据量很大，超过内存限制)个数中找最大的M个数</p>\n<pre><code class=\"java\">MinPQ&lt;Transaction&gt; pq = new MinPQ&lt;Transaction&gt;();\nwhile (StdIn.hasNextLine())\n{\n   String line = StdIn.readLine();\n   Transaction item = new Transaction(line);\n   pq.insert(item); \n   if (pq.size() &gt; M)\n      pq.delMin();\n}</code></pre>\n<h2 id=\"二叉堆实现\"><a href=\"#二叉堆实现\" class=\"headerlink\" title=\"二叉堆实现\"></a>二叉堆实现</h2><ul>\n<li><p>大顶堆(小根堆): 左右子节点小于父节点, 右子节点小于左子节点(和排序二叉树区分)</p>\n</li>\n<li><p>完全二叉树可用数组表示, 位置k的父节点为k/2, 左右子节点分别为2k和2k+1</p>\n<img src=\"/assets/blogimg/image-20220523163429676.png\" alt=\"image-20220523163429676\" style=\"zoom:80%;\">\n\n</li>\n</ul>\n<h3 id=\"堆的有序化-reheapifying\"><a href=\"#堆的有序化-reheapifying\" class=\"headerlink\" title=\"堆的有序化(reheapifying)\"></a>堆的有序化(reheapifying)</h3><blockquote>\n<p>问题: 当插入元素大于根节点的元素时(insert), 或者删除根节点的元素时(delMax)需要对堆进行重排以保证堆是有序的大顶堆</p>\n</blockquote>\n<h4 id=\"当插入的节点比根节点更大时\"><a href=\"#当插入的节点比根节点更大时\" class=\"headerlink\" title=\"当插入的节点比根节点更大时:\"></a>当插入的节点比根节点更大时:</h4><ul>\n<li>将插入的节点和它的父节点进行交换(类似于冒泡排序中的内层循环)</li>\n<li>直到整个大顶堆有序</li>\n</ul>\n<pre><code class=\"java\">private void swim(int k)\n{\n   while (k &gt; 1 &amp;&amp; less(k/2, k))\n   {\n      exch(k, k/2);\n      k = k/2;\n   }\n}</code></pre>\n<p><img src=\"/assets/blogimg/image-20220523172347153.png\" alt=\"image-20220523172347153\"></p>\n<p><strong>插入操作:</strong> 每次插入操作都要检查二叉树是否有序, 最多花费 1 + lg N 次比较</p>\n<pre><code class=\"java\">public void insert(Key x)\n{\n   pq[++N] = x;\n   swim(N);\n}</code></pre>\n<h4 id=\"当删除根节点的元素时\"><a href=\"#当删除根节点的元素时\" class=\"headerlink\" title=\"当删除根节点的元素时:\"></a>当删除根节点的元素时:</h4><ul>\n<li>将根节点和尾节点(数组最后一个元素)交换并删除尾节点;</li>\n<li>自上而下调整根节点中元素的位置</li>\n</ul>\n<p><strong>删除根节点操作:</strong></p>\n<pre><code class=\"java\">public Key delMax()\n{\n   Key max = pq[1];//记录要删除的根节点\n   exch(1, N--);//根节点和数组最后的元素交换, 然后删除数组最后一个元素\n   sink(1);//从上而下调整时使堆有序\n   pq[N+1] = null;//数组最后一个元素置为null使之能够被GC回收(防止游离)\n   return max;//返回删除的元素\n}</code></pre>\n<p><strong>自上而下调整:</strong></p>\n<ul>\n<li>将较小的根节点元素和子节点中较大的元素交换</li>\n<li>直到大顶堆有序</li>\n</ul>\n<pre><code class=\"java\">private void sink(int k)\n{\n   while (2*k &lt;= N)\n   {\n      int j = 2*k;\n      //交换子节点中的较大者\n      if (j &lt; N &amp;&amp; less(j, j+1)) j++;\n      if (!less(k, j)) break;\n      exch(k, j);\n      k = j;\n   }\n}</code></pre>\n<p><img src=\"/assets/blogimg/image-20220523175021545.png\" alt=\"image-20220523175021545\"></p>\n<h2 id=\"优先队列实现代码\"><a href=\"#优先队列实现代码\" class=\"headerlink\" title=\"优先队列实现代码\"></a>优先队列实现代码</h2><pre><code class=\"java\">public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;\n{\n   private Key[] pq;\n   private int N;\n   public MaxPQ(int capacity)\n   {  pq = (Key[]) new Comparable[capacity+1];  }\n   public boolean isEmpty()\n   {   return N == 0;   }\n   public void insert(Key key)\n   public Key delMax()\n   {   /* see previous code */  }\n   private void swim(int k)\n   private void sink(int k)\n   {   /* see previous code */  }\n   private boolean less(int i, int j)\n   {   return pq[i].compareTo(pq[j]) &lt; 0;  }\n   private void exch(int i, int j)\n   {   Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;  }\n}</code></pre>\n<table>\n<thead>\n<tr>\n<th>实现方式</th>\n<th>插入</th>\n<th>删除堆顶元素</th>\n<th>查找堆顶元素</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无序数组</td>\n<td>1</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>有序数组</td>\n<td>N</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td><strong>大顶堆</strong></td>\n<td><strong>logN</strong></td>\n<td><strong>logN</strong></td>\n<td><strong>1</strong></td>\n</tr>\n<tr>\n<td>d-ary heap</td>\n<td>log<del>d</del>N</td>\n<td>d*log<del>d</del>N</td>\n<td>1</td>\n</tr>\n</tbody></table>\n","categories":[{"name":"notebook","path":"api/categories/notebook.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"algorithm","path":"api/tags/algorithm.json"}]}